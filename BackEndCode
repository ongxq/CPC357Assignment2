#include <WiFi.h>
#include <PubSubClient.h>

// ================= WIFI =================
const char* WIFI_SSID = "Wuliwulii ";
const char* WIFI_PASSWORD = "1024$$oxq";

// ================= MQTT =================
const char* MQTT_SERVER = ""; // Insert Your GCP VM public IP
const int MQTT_PORT = 1883;
const char* MQTT_TOPIC = "iot/drain_data";

WiFiClient espClient;
PubSubClient client(espClient);

// ================= PINS =================
#define TRIG_PIN 5
#define ECHO_PIN 17
#define RAIN_PIN 23

#define GREEN_LED 25
#define YELLOW_LED 26
#define RED_LED 27

// ----------- TANK CONFIGURATION -----------
const float BOTTOM_DISTANCE = 10.08;   // cm (sensor â†’ bottom when empty)
const float SENSOR_OFFSET   = 2.0;    // cm (sensor â†’ max water level gap)
const float USABLE_HEIGHT   = BOTTOM_DISTANCE - SENSOR_OFFSET;
const int NUM_SAMPLES = 5;

// Blockage detection
unsigned long highLevelStart = 0;
float lastWaterPercent = 0;

// ================= MQTT FUNCTIONS =================
void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    if (client.connect("ESP32Client")) {
      Serial.println("Connected to MQTT server");
    } else {
      Serial.print("Failed, rc=");
      Serial.print(client.state());
      Serial.println(" Retrying in 5 seconds...");
      delay(5000);
    }
  }
}

void setupMQTT() {
  client.setServer(MQTT_SERVER, MQTT_PORT);
}

// ================= SETUP =================
void setup() {
  Serial.begin(9600);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(RAIN_PIN, INPUT);

  pinMode(GREEN_LED, OUTPUT);
  pinMode(YELLOW_LED, OUTPUT);
  pinMode(RED_LED, OUTPUT);

  // Connect WiFi
  Serial.println("Connecting WiFi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println("\nWiFi Connected!");

  // Setup MQTT
  setupMQTT();

  Serial.println("=== Drain Monitor Started ===");
  Serial.print("Bottom distance: "); Serial.print(BOTTOM_DISTANCE); Serial.println(" cm");
  Serial.print("Sensor offset: "); Serial.print(SENSOR_OFFSET); Serial.println(" cm");
  Serial.print("Usable water height: "); Serial.print(USABLE_HEIGHT); Serial.println(" cm");
  delay(1000);
}

// ================= ULTRASONIC FUNCTIONS =================
float getDistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 50000);
  if (duration == 0) return -1;

  return duration * 0.034 / 2;
}

float getAverageDistance() {
  float sum = 0;
  int count = 0;

  for (int i = 0; i < NUM_SAMPLES; i++) {
    float d = getDistance();
    if (d > 0) {
      sum += d;
      count++;
    }
    delay(50);
  }

  if (count == 0) return -1;
  return sum / count;
}

// ================= LOOP =================
void loop() {
  // Maintain MQTT connection
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  float distance = getAverageDistance();
  if (distance < 0) {
    Serial.println("âš  Ultrasonic sensor error");
    delay(3000);
    return;
  }

  // Limit blind zone
  if (distance < SENSOR_OFFSET) distance = SENSOR_OFFSET;

  // Water level calculation
  float waterDepth = USABLE_HEIGHT - (distance - SENSOR_OFFSET);
  waterDepth = constrain(waterDepth, 0, USABLE_HEIGHT);
  float waterPercent = (waterDepth / USABLE_HEIGHT) * 100.0;

  // Rain sensor (active HIGH)
  bool rainState = !digitalRead(RAIN_PIN);

  // ----------- DISPLAY -----------
  Serial.println("================================");
  Serial.print("Measured distance: "); Serial.print(distance, 2); Serial.println(" cm");
  Serial.print("Water depth: "); Serial.print(waterDepth, 2); Serial.println(" cm");
  Serial.print("Water level: "); Serial.print(waterPercent, 1); Serial.println(" %");
  Serial.println(rainState == HIGH ? "ðŸŒ§ Rain detected" : "â˜€ No rain");

  // LED CONTROL
  digitalWrite(GREEN_LED, LOW);
  digitalWrite(YELLOW_LED, LOW);
  digitalWrite(RED_LED, LOW);

  String status = "SAFE";

  if (waterPercent < 40) {
    status = "SAFE";
    digitalWrite(GREEN_LED, HIGH);
    highLevelStart = 0;
  } else if (waterPercent < 70) {
    status = "CAUTION";
    digitalWrite(YELLOW_LED, HIGH);
  } else {
    status = "CRITICAL";
    digitalWrite(RED_LED, HIGH);
    if (highLevelStart == 0) highLevelStart = millis();
    if (millis() - highLevelStart > 172800000) {
      Serial.println("âš  BLOCKAGE DETECTED (48h high water)");
    }
  }

  // Rapid rise alert
  if (waterPercent > lastWaterPercent + 20) {
    Serial.println("ðŸš¨ RAPID WATER LEVEL RISE!");
    for (int i = 0; i < 3; i++) {
      digitalWrite(RED_LED, HIGH);
      delay(300);
      digitalWrite(RED_LED, LOW);
      delay(300);
    }
  }

  // Rain + high water alert
  if (rainState == HIGH && waterPercent >= 40) {
    Serial.println("ðŸŒ§âš  RAIN + HIGH WATER â€” Check drain!");
  }

  // ----------- MQTT PUBLISH -----------
  String payload = "{";
  payload += "\"water_level\":" + String(waterPercent, 1) + ",";
  payload += "\"water_depth\":" + String(waterDepth, 2) + ",";
  payload += "\"distance\":" + String(distance, 2) + ",";
  payload += "\"rain_state\":" + String(rainState ? "true" : "false") + ",";
  payload += "\"status\":\"" + status + "\"";
  payload += "}";

  client.publish(MQTT_TOPIC, payload.c_str());
  Serial.println("Published to MQTT: " + payload);

  lastWaterPercent = waterPercent;
  delay(5000);
}
